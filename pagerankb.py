# -*- coding: utf-8 -*-
"""pagerankB.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mvK6F_gkDhkWpr2d5ETdkQg0l3C1RaH2

# Google PageRank
"""

import numpy as np
import numpy.linalg as la
import networkx as nx
import matplotlib.pyplot as plt

"""## Preamble: eigenvalues and eigenvectors"""

def eig(title, M):
  l, v = la.eig(M)
  print(f"\n {title} ")
  print("="*(len(title)+2))
  print(f"Eigenvalues: {l}")
  print(f"Eigenvectors:\n{v}")
  plt.figure(figsize=(4, 4))
  for i in range(len(v)):
    plt.xlim((-1.1, 1.1))
    plt.ylim((-1.1, 1.1))
    plt.axvline(0, lw=0.1)
    plt.axhline(0, lw=0.1)
    plt.plot([0, v[i, 0]], [0, v[i, 1]], '-o')
  plt.show()

# diagonale
eig("Diagonal", [[1, 0], 
                 [0, 2]])

# skewed
eig("Skewed", [[2, 0],
               [1, 1]])

# rotation
eig("Rotated", [[1, -1],
                [-1, 1]])

"""## Example graph

Let us create and visualize a connectivity graph.
"""

A = np.array([
    [0, 0, 0, 0, 0, 0, 0],
    [1, 0, 0, 1, 0, 0, 0],
    [0, 0, 0, 0, 0, 1, 0],
    [1, 0, 0, 0, 0, 0, 0],
    [0, 1, 1, 0, 0, 0, 0],
    [1, 0, 0, 1, 0, 0, 0],
    [1, 1, 1, 1, 1, 1, 0]
])

def plot_graph(A, node_size=1/A.shape[0], node_color="#ccc"):
    g = nx.from_numpy_matrix(A.T, create_using=nx.DiGraph())
    nx.draw_shell(g, labels=dict((i, str(i+1)) for i in g.nodes), arrows=True,
                     node_size=10000*node_size, node_color=node_color)
plot_graph(A)

"""We normalize the adjacency matrix so that it fits the PageRank algorithm. We re-plot the graph to make sure normalization worked right. """

norms = np.sum(A, axis=0)
norms[norms==0]=1
A = A/norms

plot_graph(A, node_color="#9cf")

A

"""First, let's compute page ranks using the iterative algorithm. The iterative algorithm scales well to huge matrices."""

def pagerank_iterative(A, num_iterations=100, d=0.85):
    """PageRank: The trillion dollar algorithm.

    Parameters
    ----------
    A : numpy array
        adjacency matrix where A_i,j represents the link from 'j' to 'i', 
        such that for all 'j' sum(i, A_i,j) = 1
    num_iterations : int, optional
        number of iterations, by default 100
    d : float, optional
        damping factor, by default 0.85

    Returns
    -------
    numpy array
        a vector of ranks such that v_i is the i-th rank from [0, 1],
        v sums to 1

    """
    N = A.shape[1]
    v = np.random.rand(N, 1)
    v = v / np.linalg.norm(v, 1)
    for i in range(num_iterations):
        v = d * A @ v + (1 - d)/N
    return v[:,0]

np.random.rand(7, 1)

vi = pagerank_iterative(A, num_iterations=100000,  d=0.65)
plot_graph(A, node_color='#fc9', node_size=vi)
vi

"""Now, let's do the same using the closed form matrix expression and verify that we get the same results."""

def pagerank_algebraic(A, d=0.85):
    """PageRank: The trillion dollar algorithm.

    Parameters
    ----------
    A : numpy array
        adjacency matrix where A_i,j represents the link from 'j' to 'i',
        such that for all 'j' sum(i, A_i,j) = 1
    d : float, optional
        damping factor, by default 0.85

    Returns
    -------
    numpy array
        a vector of ranks such that v_i is the i-th rank from [0, 1],
        v sums to 1

    """
    N = A.shape[0]
    return  la.inv(np.eye(N) - d * A) @ ((1-d)/N*np.ones(N).T)

va = pagerank_algebraic(A)
plot_graph(A, node_color='#9fc', node_size=va)
va-vi

va - vi

